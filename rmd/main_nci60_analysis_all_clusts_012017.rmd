---
title: "Model-based clustering of GI50 profiles of NCI60 cell lines"
author: "Kenichi Shimada"
date: 09-18-2014
output:
  html_document:
    toc: true
    toc_float: true
    toc_depth: 3
    fig_caption: true
---
## 1. Overview
This is analysis of NCI60 project. Refer to [Shimada et al. (Cell Chemical Biology, 2016)](https://www.ncbi.nlm.nih.gov/pubmed/26853626) for the details. Some preprocessing was cut; look at 
__main_nci60_analysis_all_clusts_110215.r__ instead.


## 2. Loading data and packages
```{r setup,echo=F}
dir <- "~/Projects_BRS/2_pharmacogenomics/nci60_analysis"
opts_chunk$set(eval=F,echo=T)
opts_knit$set(root.dir=dir)
```

```{r loading,eval=T}
library(gplots) ## heatmap.2 function
library(RColorBrewer) ## gradation of colors in heatmap
library(mclust) ## model-based clustering
library(robustbase) ## lmrob for robust linear regression
library(org.Hs.eg.db) ## Gene ID <=> Gene SYMBOL
library(parallel) ## mclapply to use multiple cores

## number of cores to use in parallel packages
n.cores <- parallel:::detectCores() 

# functions
source("src/rfunctions.r") 
# distfun, GSEAEnrichmentScore, GSEA.EnrichmentScore2, GSEA.EnrichmentScore3, hclustfun, myheatmap, pvals.ES.GSEA, TEA.hpc

## data
load("rda/nci60-analysis.rda")

# gi: logGI50 values of 75446 (50839 unique) compounds in 59 cell lines
# gi.fin: logGI50 values of 21 (10 unique) compounds in 59 cell lines
# tissues: cell line name and tissue origins
# log.txn.ge80: RMA-transformed microarray data of 59 cell lines, selected genes within top 80% IQRs
# corrs: matrix containing the Spearman correlation between
# es.pvals: Each pathway's enrichment score and the p-value computed using GSEA.
# msigdb: MsigDB pathway data (version 3.1)
# slogp.fin.gos: signed log P-values of ferroptosis-associted GOs, to generate Extended Data Fig. 9b
```

## 3. Computing GI50 profiles
### Compute median GI50s

Gene expression and drug sensitivity data were downloaded from the NCI60 website. For each compound, a unique GI50 profile was computed by taking the median of the replicates. In this computation, missing values are ignored.

```{r median_GI50,eval=T}
cmpds <- sub("\\..+","",rownames(gi)) ## 75446 compounds
uniq.cmpds <- unique(cmpds) ## 50839 unique compounds
load("rda/med.gi.rda") ## med.gi, no missing values
```

### Select GI50 profiles with no missing values and IQR>0
```{r select_cmpds,eval=T}
n.tested.cells <- apply(med.gi,1,function(x)sum(!is.na(x)))
iqrs <- apply(med.gi, 1, function(x)diff(quantile(x,c(.25,.75),na.rm=T))) #interquartile range (IQR)
used.gi <- med.gi[n.tested.cells == 59&iqrs>0,] ## 6249 compounds were selected
```

### Compute GI50 profiles of ferroptosis inducers 
```{r comp_gi50_fin,eval=T}
uniq.fin <- unique(sub("\\..+","",rownames(gi.fin))) ## 10 compounds
# "CIL56","FIN56","erastin","AE","PE","MEII","RSL3","1S3R","ML162","ML210"

## computing a unique GI50 profile for each ferroptosis inducer
used.gi.fin <- t(sapply(uniq.fin,function(ur){
  thism <- apply(gi.fin[grep(paste("^",ur,"\\.",sep=""),rownames(gi.fin)),],
                 1,function(x)x-median(x,na.rm=T))
  x <- apply(thism,1,median,na.rm=T)
  return(x)
}))

## replace a missing value with an estimate
used.gi.fin["MEII","LC:EKVX"] <- mean(used.gi.fin[c("AE","PE","erastin"),"LC:EKVX"])
```

### Select cell-line-selective compounds
```{r comp_iqrs,eval=T}
## IQRs of 6249 compounds and 10 ferroptosis inducers
used.iqrs <- apply(used.gi, 1, function(x)diff(quantile(x,c(.25,.75),na.rm=T))) ## 6249
used.iqrs.fin <- sort(apply(used.gi.fin, 1, function(x)diff(quantile(x,c(.25,.75),na.rm=T)))) ## 10
```
```{r echo=F,eval=T,results="hide"}
par(mfrow=c(1,2))

## Fig. 2a: barplot of cell-line-selectivity with in ferroptosis inducers
mir <- used.iqrs.fin##;names(mir)[8] <- "RSL-CIL56"
fi.class <- list(gsh=c("erastin","AE","PE","MEII"),
                 gpx4=c("RSL3","1S3R","ML162","ML210"),
                 cil56=c("CIL56","FIN56"))
fi.mir <- lapply(fi.class[1:3],function(x)mir[x])
cols <- 1##brewer.pal(3,"Set2")
par(mar=c(7,5,1,1)+.1)
plot(c(1,3),range(c(0,unlist(fi.mir))),type="n",xlim=c(.8,4),
     axes=F,xlab="",ylab="Cell-line selectivity",main="FINs selectivity")
abline(v=1:3,col="grey80")
par(xpd=T)
set.seed(123)
sapply(1:3,function(i){
  mir1 <- fi.mir[[i]]
  xs <- jitter(rep(i,length(mir1)),amount=.15)
  points(xs,mir1,col=1,pch=20,cex=1)
  ##text(xs,mir1,names(mir1),pos=4)
})
par(xpd=F)
axis(1,at=1:3,labels=c("GSH depletors","GPX4 inhibitors","CIL56 analogs"),las=2)
axis(2)
abline(h=min(unlist(fi.mir[1:2])),col=2,lty=2)

## Fig. 4a: boxplot of cell-line selectivity (IQR of each GI50 profile)
par(mar=c(7,4,1,7)+.1)
mir <- used.iqrs.fin##;names(mir)[8] <- "RSL-CIL56"
mgi50 <-  list(mir,used.iqrs)
a <- boxplot(mgi50,border=NA,cex=0,axes=F)
axis(2)
axis(1,at=1:2,labels=c("Others","Ferroptosis"),las=2)
boxplot(mgi50[2:1],cex=0,axes=F,add=T,border="grey40",main="All cmpds selectivity")
set.seed(1245)
points(jitter(rep(1,length(mgi50[[2]])),amount=.2),mgi50[[2]],pch=20,cex=.15,col="grey70")
set.seed(1245)
cols <- brewer.pal(6,"Set1")
iqrs.fins.cols <- "grey20"##cols[c(2,2,2,2,3,3,3,1,3)]
abline(h=min(mgi50[[1]][-1]),col=2,lty=2)
points(jitter(rep(2,length(mgi50[[1]])),amount=.2),mgi50[[1]],pch=20,cex=.7,col=iqrs.fins.cols)
```

```{r select_selectives,eval=T}
# Selecting cell line-selective compounds
has.large.iqr <- used.iqrs > min(used.iqrs.fin[-1]) ## 2555 compounds
pval <- t.test(used.iqrs, used.iqrs.fin)$p.value ## 0.00869
sele.gi <- rbind(used.gi[has.large.iqr,],used.gi.fin) ## GI50 values of 2565 cell-line-selective lethals
```


## 4. Clustering GI50 profiles
### Choose optimal number of clusters using BIC
```{r choose_g,echo=T,eval=F}
## find the optimal model and # of clusters
n.clusts.range <-  40:60
system.time({## 244 secs
  bics <- mclustBIC(sele.gi,G=n.clusts.range,modelNames=c("EII","VII"),
                    prior=priorControl())
})
max.ind <- which(bics==max(bics),arr.ind=T)
model <- colnames(bics)[max.ind[2]] ## optimal model: VII
g <- as.numeric(rownames(bics)[max.ind[1]]) ## optimal # of clusters: 53
# save(n.clusts.range,bics,max.ind,model,g,file="rda/bics.rda")
```
```{r choose_g_2,echo=F,eval=T}
model <- "VII"
g <-  53
```
```{r echo=F,eval=T}
plot(n.clusts.range,bics[,model],type="b",
     xlab="# of clusters",ylab="Bayesian Information Criterion",
     main=paste("model:",model))
abline(v=g,col=2)
```

__Mclust()__ chose 53 clusters(=g).


```{r echo=T,eval=F}
system.time(mc <- Mclust(sele.gi,G=g,modelNames=model,prior=priorControl())) ## 47 secs
save(mc,file="mc.rda")
```
```{r echo=F,eval=T}
load("rda/mc.rda")
```

### Further investigation of grouped compounds.
```{r eval=T}
## Discover the ferroptosis cluster.
mem <- mc$classification ## compounds' memberships
mem.fins <- mem[uniq.fin]
fin.clust <- names(sort(table(mem.fins),decreasing=T))[1] ## ferroptosis cluster is "1"-st cluster

## GI50 profile of each cluster
gi.clust <- sapply(seq(g),function(m)apply(sele.gi[mem==m,],2,median)) ## gi50 profiles of the 53 clusters
colnames(gi.clust) <- as.character(seq(g))
```

```{r eval=T,echo=F}
par(mfrow=c(1,2))

## Fig 4b heatmap (clusters vs nci60 cells lines)
colors <- c("white","red")[seq(as.numeric(g)) %in% fin.clust+1]
xx <- myheatmap(gi.clust,cexRow=.5,cexCol=.5,keysize=1.5,RowSideColors=colors)

## Fig 4b barplot (# cmpds per cluster)
tab.fins <- table(mem,rep(0:1,c(2555,10)));rownames(tab.fins) <- as.character(1:53)
sort.tab.fins <- tab.fins[xx$rowInd,]
barplot(t(sort.tab.fins[,2:1]),beside=F,las=2,col=c(2,"lightblue"),horiz=T,cex.names=.3,border=NA)

## Fig 4b heatmap (clusters vs nci60 cells lines)
colors <- c("white","red")[seq(as.numeric(g)) %in% fin.clust+1]
xx <- myheatmap(gi.clust,cexRow=.5,cexCol=.5,keysize=1.5,RowSideColors=colors)

## Fig 4d boxplot IQR
sele.iqrs <- apply(sele.gi,1,IQR)
clust.iqrs <- sapply(seq(g),function(m)sele.iqrs[mem==m]) ## gi50 profiles of the 53 clusters
names(clust.iqrs) <- seq(g)
boxplot(clust.iqrs[as.character(xx$rowInd)],las=2,col="lightblue",
  horizontal=T,cex=.1,pch=20,cex.axis=.3,lwd=.5)

par(mfrow=c(1,1))
## Fig 4c
gi50.within.fi.clust <- t(sele.gi[mem==fin.clust,])
myheatmap(gi50.within.fi.clust[xx$colInd,],cexRow=.7,cexCol=.5,keysize=2,
          Colv=FALSE,dendrogram="row")

## iqrs - n.cmpds
n.cmpds.clust <- sapply(clust.iqrs,length)
clust.iqrs.med <- sapply(clust.iqrs,median)
clust.iqrs.mean <- sapply(clust.iqrs,mean)
clust.iqrs.iqr <- sapply(clust.iqrs,function(x)quantile(x,c(.25,.75)))
plot(clust.iqrs.med,n.cmpds.clust,pch=20,col=rep(2:1,c(1,52)),type="n",xlim=range(clust.iqrs.iqr))
x <- sapply(1:53,function(i)lines(clust.iqrs.iqr[,i],rep(n.cmpds.clust[i],2),col="grey80"))
points(clust.iqrs.med,n.cmpds.clust,pch=20,col=rep(2:1,c(1,52))) ## average RMS - n.cmpds
```

```{r cutree,eval=T}
## 53 -> 18 clusters
source("src/cutree_110215.r")
```

## 5. Compute correlation between Transcriptome and GI50 profiles

Transcriptome data are available [here](https://wiki.nci.nih.gov/display/NCIDTPdata/Molecular+Target+Data),
where I chosed GENELOGIC's U133 microarray data (RMA-normalized). Reorder cell lines in the data so that it be the same between the GI50 and the transcription matrices. 

### Subset genes used in both GOs and txns 
```{r select_genes_from_GO,eval=T, results="hide"}
t.gi50 <- t(gi.clust18) ##transpose GI50 profiles
colnames(t.gi50) <- sub(":",".",colnames(t.gi50))

txn <- log.txn.ge80[,colnames(t.gi50)] ## transcriptional expression
identical(colnames(t.gi50),colnames(txn)) ## TRUE
GOs <- msigdb[grep("^GO",names(msigdb))] ## 1454 GOs

## genes that are in both transcriptome (txn) and pathway database (msigdb) are tested
txns <- rownames(txn)
genes <- unique(unlist(msigdb)) ## all the genes annotated in msigdb
used.genes <- genes[genes %in% txns] ## 10850 genes' expression is measured
used.msigdb <- lapply(msigdb,function(x)x[x %in% used.genes]) ## removed genes not measured from msigdb
msigdb.ge10 <- used.msigdb[sapply(used.msigdb,length)>=10] ##2763 gene sets contain 10 genes or more
used.genes.ge10 <- unique(unlist(msigdb.ge10)) ## 10850 genes in the above gene sets
GOs.ge10 <- msigdb.ge10[grep("^GO",names(msigdb.ge10))] ## 1222 gene sets are Gene Ontology terms
```
### Compute correlation between txn and drug sensitivity
Spearman correlation btwn each gene expression and each GI50 profile among 59 cell lines

```{r eval=F,echo=T}
## 10850 genes x 53 compound clusters ## 152 secs with n.cores=8
system.time(corrs <- mclapply(rownames(t.gi50),function(cmpd){
  sapply(used.genes.ge10,function(gid){
    cor(txn[gid,],t.gi50[cmpd,],method="spearman",use="complete.obs")
  })
},mc.cores=(n.cores-1)))
corrs <- do.call(cbind,corrs)
colnames(corrs) <- rownames(t.gi50)
rownames(corrs) <- used.genes.ge10

```
```{r eval=T,echo=F}
load("rda/corrs.rda") ## corrs
```

### Sort the genes based on corrs against FINs
```{r sort_genes,eval=T}
pos.ordered.genes <- names(sort(corrs[used.genes.ge10,fin.clust],decreasing=T))

## max and min corrs re FINs
max.corr.txn <- head(pos.ordered.genes,1) ## GeneID: 1728
max.sym <- mget(max.corr.txn,org.Hs.egSYMBOL) ## SYMBOL: NQO1
max.corr <- cor(txn[max.corr.txn,],gi.clust[,fin.clust],method="spearman")

min.corr.txn <- tail(pos.ordered.genes,1) ## GeneID: 84142
min.sym <- mget(min.corr.txn,org.Hs.egSYMBOL) ## SYMBOL: FAM175A
min.corr <-  cor(txn[min.corr.txn,],gi.clust[,fin.clust],method="spearman")
```

```{r scatterplots,eval=T,echo=F}
## Extended Data Fig. 9a histogram
hist(corrs[,fin.clust],pch=20,cex=.1,axes=T,ylab="Spearman Coef.(mRNA vs GI50)",breaks=30,col="grey80")
abline(v=0)

## Extended Data Fig. 9a max vs min genes
par(mfrow=c(1,2))
par(mar=c(5,5,3,3)+.1)
plot(txn[max.corr.txn,],t.gi50[fin.clust,],pch=20,
     xlab=paste(max.sym,"mRNA"),ylab="logGI50",main="",cex=.7)
coef<- summary(lmrob(t.gi50[fin.clust,]~txn[max.corr.txn,]))$coef[1:2]
abline(coef,col=2)

plot(txn[min.corr.txn,],t.gi50[fin.clust,],pch=20,
     xlab=paste(min.sym,"mRNA"),ylab="logGI50",cex=.7)
coef<- summary(lmrob(t.gi50[fin.clust,]~txn[min.corr.txn,]))$coef[1:2]
abline(coef,col=2)
```

## 6. Pathway enrichment analysis
### compute signed-logP values for each pathways
I chose the non-parametric permutation to compute KS statistics, but this depends on seeds used by RNG and computationally very expensive. So here I chose to use a new [npGSEA algorithm](https://www.bioconductor.org/packages/release/bioc/html/npGSEA.html).

```{r comp_ES,eval=T,results="hide"}
## for all classes
grps <- colnames(corrs)
system.time(es.grps <- sapply(grps,function(grp){
    pos <- names(sort(corrs[,grp],decreasing=T))
    ES.grp <- sapply(GOs.ge10,function(go){
        set.seed(12345)
        GSEA.EnrichmentScore3(pos,go)
    })
})) ## 16.8 secs
```

### two criteria: selectivity and pecificity.

```{r}
## two criteria:
ns <- names(GOs.ge10)
own <- 3;others <- 3
sigs <- lapply(1:18,function(g){
  ## max
  m1 <- apply(slp18.3,1,function(x){
    i1 <- which.max(x);
    if(i1==g){
      tf <- x[i1]> own && max(x[-i1]) < others
      return(tf)
    }else{
      return(FALSE)
    }
  });maxi <- which(m1)
  m2 <- apply(slp18.3,1,function(x){
    i1 <- which.min(x);
    if(i1==g){
      tf <- x[i1]< -own && max(x[-i1]) > -others
      return(tf)
    }else{
      return(FALSE)
    }
  });mini <- which(m2)
  return(list(pos=ns[m1],neg=ns[m2]))
})
names(sigs) <- colnames(gi.clust18)
sig.names <- sub("^GO_","",unique(unlist(sigs)));names(sig.names) <- c()

##
m <- sapply(sigs,function(x)length(unlist(x)))
```

### Analysis of Overlapped genes between GOs
Analysis of overlapped genes between GO Terms: discover hierarchical structures among GO Terms

```{r overlap}
pos.overlap <- sapply(pos.corr.gos,function(i){
  sapply(pos.corr.gos,function(j){
    sum(GOs.ge10[[i]] %in% GOs.ge10[[j]])/min(sapply(GOs.ge10[c(i,j)],length))
  })
})
pos.goids <- names(pos.corr.gos)
colnames(pos.overlap) <- rownames(pos.overlap) <- pos.goids
##
neg.overlap <- sapply(neg.corr.gos,function(i){
  sapply(neg.corr.gos,function(j){
    sum(GOs.ge10[[i]] %in% GOs.ge10[[j]])/min(sapply(GOs.ge10[c(i,j)],length))
  })
})
neg.goids <- names(neg.corr.gos)
colnames(neg.overlap) <- rownames(neg.overlap) <- neg.goids
```

```{r heatmap,eval=F,echo=F}
## overlap between GOs
cols <- colorRampPalette(c("white","darkblue"))(10)
n1 <- heatmap.2(pos.overlap,col=cols,trace="none",
                margin=c(10,10),cexRow=.7,cexCol=.7,
                hclustfun=hclustfun,
                distfun=distfun) ## overlap of genes between positively correlated GOs.
n2 <- heatmap.2(neg.overlap,col=cols,trace="none",
                margin=c(10,10),cexRow=.7,cexCol=.7,
                hclustfun=hclustfun,
                distfun=distfun) ## overlap of genes between negatively correlated GOs.

## Extended Data Fig.9c Significant and Exclusive GO Terms against the Ferroptosis Cluster.
ordered.sig.gos <- c(pos.corr.gos[rev(n1$rowInd)],neg.corr.gos[rev(n2$rowInd)])

## Extended Data Figure 9b: ferroptosis-associated GOs against all the clusters.
setwd(dir)
source("EDFig9b_compute_pvalues.r")
```
### NAD(P)(H)-dependent gene set 
```{r eval=T}
nadph.genes <- unlist(GOs.ge10[ c("GO_OXIDOREDUCTASE_ACTIVITY_GO_0016616",
                                  "GO_OXIDOREDUCTASE_ACTIVITY_ACTING_ON_NADH_OR_NADPH")])
```
```{r eval=F}
library(qvalue)
qvalue(0.1^abs(slp.nadph) ) : not working...
##
setwd(dir);setwd("figs")
pdf("slp.nadph.pdf",width=3,height=5)
set.seed(1234);xs <- jitter(rep(1,18),amount=.15)
ys <- slp.nadph
plot(xs,ys,pch=20,xlim=c(0,2),axes=F,type="n",ylim=c(-2,8),
     ylab="-log10 p-value")
abline(v=1,col="grey80")
abline(h=0)
points(xs,ys,pch=20)
axis(2,at=seq(-2,8,2))
dev.off()
```

### Plot summarizing GSEA
```{r}

if(0){
  r1 <- GSEA.EnrichmentScore(pos.ordered.genes,nadph.genes,weighted.score.type=0,correl.vector=NULL)
  ## Extended Data Fig. 9d: Visualizing Enrichment of NAD(P)(H)-dependent gene set
  setwd(fig.dir)
  pdf("EDFigure_9d.pdf",width=5,height=5)
  plot(c(-0.08,r1$RES),type="n",xlab="",ylab="",axes=F,
       main="Gene Set (GO:0016616 + GO:0016651)")
  lines(rep(r1$arg.ES,2),c(0,r1$ES),col="grey60",lty=2)
  lines(c(par()$usr[1],r1$arg.ES),rep(r1$ES,2),col="grey60",lty=2)
  lines(c(0,r1$RES),col=3,lwd=2)
  mtext("Running ES",2,line=3)
  mtext("Gene Index",1,line=3)
  ind <- which(r1$indicator==1)+1
  x <- sapply(seq(ind),function(i)lines(rep(ind[i],2),c(0,-.04),col=2))
  cor.fi <- sort(corrs[pos.ordered.genes,fin.clust],decreasing=T)
  rn <- range(cor.fi,na.rm=T)
  rng <- round(rn/max(abs(rn))*256)
  cols <- colorRampPalette(c("blue","white","red"))(513)[match(seq(rng[1],rng[2]),-256:256)]
  scale <- seq(rn[1],rn[2],length.out=length(cols))
  x <- sapply(seq(r1$RES),function(i){
    j <- which.min(abs(scale-cor.fi[i]))
    lines(rep(i,2)+1,c(-.04,-.08),col=cols[j])
  })
  abline(h=c(0,-.04))
  box()
  axis(2,at=seq(0,.4,.1),las=1)
  axis(1,at=c(0,5000,10000))
  dev.off()
  
  ## Extended Data Fig. 9e
  border <- r1$arg.ES
  ranks <- which(r1$indicator==1)
  nadph.eids <- pos.ordered.genes[ranks]
  nadph.symbols <- unlist(mget(nadph.eids,org.Hs.egSYMBOL))
  nadph.tab <- cbind(rank=ranks,
                     gene.symbol=nadph.symbols,
                     entrez.id=nadph.eids)
  ind.16 <- which(nadph.eids %in% GOs.ge10[["GO_OXIDOREDUCTASE_ACTIVITY_GO_0016616"]])
  ind.51 <- which(nadph.eids %in% GOs.ge10[["GO_OXIDOREDUCTASE_ACTIVITY_ACTING_ON_NADH_OR_NADPH"]])
  write.csv(nadph.tab[ind.16,],"EDFigure_9e_genes_go_0016616.csv",row.names=F)
  write.csv(nadph.tab[ind.51,],"EDFIgure_9e_genes_go_0016651.csv",row.names=F)
}


es.nadph <- sapply(grps,function(grp){ ## enrichment score of NAD(P)(H)-dependent genes against 53 clusters.
  pos <- names(sort(corrs[used.genes.ge10,grp],decreasing=T))
  set.seed(12345)
  ES.grp <- GSEA.EnrichmentScore3(pos,nadph.genes)
})
     
## p-values of NAD(P)(H)-associated redox genes
system.time(p0 <- sapply(grps,function(grp){ # 63 secs
  pos <- names(sort(corrs[used.genes.ge10,grp],decreasing=T))
  pvals.ES.GSEA(pos,nadph.genes,nperm=1000)$p.value
}))
##
ind.p0 <- which(p0<0.01)
system.time(p1 <- sapply(ind.p0,function(i){ # 151 secs (53 secs)
  pos <- names(sort(corrs[used.genes.ge10,i],decreasing=T))
  pvals.ES.GSEA(pos,nadph.genes,nperm=1e4)$p.value
}))
##
ind.p1 <- names(p1)[which(p1<1e-3)] ## only "1"
if(0){
  system.time({ ## takes 4.6 hours with 7 cores
    nperm <- 1e8
    pos <- names(sort(corrs[used.genes.ge10,"1"],decreasing=T))
    original.ES <- GSEA.EnrichmentScore3(pos,nadph.genes)
    perm.ES <- unlist(mclapply(seq(nperm),function(i){
      set.seed(i)
      GSEA.EnrichmentScore3(sample(pos),nadph.genes)
    },mc.cores=7,mc.set.seed=FALSE))
    p.value <- min(sum(perm.ES > original.ES),sum(perm.ES < original.ES))/nperm
    p2 <- p.value ## p2 <- 3e-08
  })
}else{
  p2 <- c(`1`=3e-08)
}
```

## 7. Session info
```{r sessionInfo,eval=T}
sessionInfo()
```
```{r eval=F,echo=F}
# R version 2.15.2 (2012-10-26)
# Platform: x86_64-apple-darwin9.8.0/x86_64 (64-bit)
# 
# locale:
# [1] C
# 
# attached base packages:
# [1] grid      parallel  stats     graphics  grDevices utils     datasets 
# [8] methods   base     
# 
# other attached packages:
#  [1] org.Hs.eg.db_2.8.0   RSQLite_0.11.2       DBI_0.2-5           
#  [4] AnnotationDbi_1.20.7 Biobase_2.18.0       BiocGenerics_0.4.0  
#  [7] robustbase_0.9-7     mclust_4.0           gplots_2.11.0       
# [10] MASS_7.3-23          KernSmooth_2.23-10   caTools_1.14        
# [13] gdata_2.12.0         gtools_2.7.1         RColorBrewer_1.0-5  
# [16] kslib_2.2           
# 
# loaded via a namespace (and not attached):
# [1] IRanges_1.16.6  bitops_1.0-4.2  compiler_2.15.2 stats4_2.15.2  
# [5] tools_2.15.2
```